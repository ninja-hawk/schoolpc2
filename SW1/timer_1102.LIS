                         4 .list
                         5 ***************************************************************
                         6 ** 各種レジスタ定義
                         7 ***************************************************************
                         8 
                         9 ***************
                        10 ** レジスタ群の先頭
                        11 ***************
                        12 .equ REGBASE, 0xFFF000  | DMAP を使用.
                        13 .equ IOBASE,  0x00d00000
                        14 
                        15 ***************
                        16 ** 割り込み関係のレジスタ
                        17 ***************
                        18 .equ IVR,     REGBASE+0x300 | 割り込みベクタレジスタ
                        19 .equ IMR,     REGBASE+0x304 | 割り込みマスクレジスタ
                        20 .equ ISR,     REGBASE+0x30c | 割り込みステータスレジスタ
                        21 .equ IPR,     REGBASE+0x310 | 割り込みペンディングレジスタ
                        22 
                        23 
                        24 ***************
                        25 ** タイマ関係のレジスタ
                        26 ***************
                        27 .equ TCTL1,   REGBASE+0x600 | タイマ1コントロールレジスタ
                        28 .equ TPRER1,  REGBASE+0x602 | タイマ1プリスケーラレジスタ
                        29 .equ TCMP1,   REGBASE+0x604 | タイマ1コンペアレジスタ
                        30 .equ TCN1,    REGBASE+0x608 | タイマ1カウンタレジスタ
                        31 .equ TSTAT1,  REGBASE+0x60a | タイマ1ステータスレジスタ
                        32 ***************
                        33 ** UART1 (送受信)関係のレジスタ
                        34 ***************
                        35 .equ USTCNT1, REGBASE+0x900 | UART1 ステータス / コントロールレジスタ
                        36 .equ UBAUD1,  REGBASE+0x902 | UART1 ボーコントロールレジスタ
                        37 .equ URX1,    REGBASE+0x904 | UART1 受信レジスタ
                        38 .equ UTX1,    REGBASE+0x906 | UART1 送信レジスタ
                        39 ***************
                        40 ** LED
                        41 ***************
                        42 .equ LED7,  IOBASE+0x000002f | ボード搭載のLED用レジスタ
                        43 .equ LED6,  IOBASE+0x000002d | 使用法については付録 A.4.3.1
                        44 .equ LED5,  IOBASE+0x000002b
                        45 .equ LED4,  IOBASE+0x0000029
                        46 .equ LED3,  IOBASE+0x000003f
                        47 .equ LED2,  IOBASE+0x000003d
                        48 .equ LED1,  IOBASE+0x000003b
                        49 .equ LED0,  IOBASE+0x0000039
                        50 
                        51 ***************************************************************
                        52 ** スタック領域の確保
                        53 ***************************************************************
                        54 .section .bss
                        55 .even
                        56 SYS_STK:
0009d0 0000 0000        57 		.ds.b  0x4000 | システムスタック領域
       0000 0000        57 
       0000 0000        57 
       0000 0000        57 
       0000 0000        57 
                        58 		.even
                        59 SYS_STK_TOP: 		      | システムスタック領域の最後尾
                        60 
0049d0 0000 0000        61 task_p:		.ds.l 1		| タイマ割り込み時に起動するルーチン先頭アドレス代入用
                        62 
                        63 ***************************************************************
                        64 ** 初期化
                        65 ** 内部デバイスレジスタには特定の値が設定されている.
                        66 ** その理由を知るには,付録 B にある各レジスタの仕様を参照すること.
                        67 ***************************************************************
                        68 .section .text
                        69 .even
                        70 boot:
                        71 		* スーパーバイザ & 各種設定を行っている最中の割込禁止
000400 46FC 2000        72 		move.w #0x2000,%SR /* superviser-mode level 0 */
000404 4FF9 0000        73 		lea.l SYS_STK_TOP, %SP | Set SSP
       0000             73 
                        74 		****************
                        75 		** 割り込みコントローラの初期化
                        76 		****************
00040a 13FC 0040        77 		move.b #0x40, IVR      | ユーザ割り込みベクタ番号を
       00FF F300        77 
                        78 		                       | 0x40+level に設定.
000412 23FC 00FF        79 		move.l #0x00ff3ff9,IMR | 全割り込みマスク
       3FF9 00FF        79 
       F304             79 
                        80 		****************
                        81 		** 送受信 (UART1) 関係の初期化 ( 割り込みレベルは 4 に固定されている )
                        82 		****************
00041c 21FC 0000        83 		move.l #UART1_interrupt, 0x110  | 受信割り込みベクタをセット
       0000 0110        83 
000424 33FC 0000        84 		move.w #0x0000, USTCNT1 | リセット
       00FF F900        84 
                        85 		/* バグの原因はここ(下)であることが多い  */
00042c 33FC E108        86 		move.w #0xe108, USTCNT1 | 送受信可能 , パリティなし , 1 stop, 8 bit, /* 変更 */
       00FF F900        86 
                        87 					| 受信割り込み許可, 送割り込み禁止
000434 33FC 0038        88 		move.w #0x0038, UBAUD1  | baud rate = 230400 bps
       00FF F902        88 
                        89 		****************
                        90 		** タイマ関係の初期化 ( 割り込みレベルは 6 に固定されている )
                        91 		*****************
00043c 33FC 0004        92 		move.w #0x0004, TCTL1   | restart, 割り込み不可 ,
       00FF F600        92 
                        93 					| システムクロックの 1/16 を単位として計時,
                        94 					| タイマ使用停止
                        95                 
000444 4EBA 0092        96                 jsr Init_Q              | キューの初期化 
000448 6000 0318        97 		bra MAIN
                        98 
                        99 *************************************
                       100 ** UART1_interrupt
                       101 ** 送受信割り込みを扱うインターフェース
                       102 ** #0d8192 = 0b0010_0000_0000_0000
                       103 ** #0x8000 = 0b1000_0000_0000_0000
                       104 *************************************
                       105 /* btst : 指定データの指定ビットが0であるか判断し、0であればCCRのZに0を
                       106 UART1_interrupt:
                       107 		/* 受信FIFOが空でないとき(URX[13]==1)受信割り込みであると判断 */
                       108 		/* URX[13] ->  0: 受信FIFOが空, 1: 受信FIFOが空でない */
00044c 3639 00FF       109 		move.w URX1, %d3
       F904            109 
000452 1403            110 		move.b %d3, %d2       |  %d3.wの下位8bitを%d2.bにコピー
000454 0243 2000       111                 andi.w #8192, %d3     |  URX1と#8192をAND演算
000458 0C43 0000       112 		cmpi.w #0, %d3        |  
00045c 6700 000C       113 		beq    CALL_INTERPUT  |  if URX1[13] == 0 (受信FIFOが空のとき)
000460 7200            114 		move.l #0, %d1        |  ch = 0 を明示
000462 4EBA 0062       115 		jsr    INTERGET       |  受信割り込み時処理
000466 6000 001A       116 		bra    END_interrupt
                       117 CALL_INTERPUT:
                       118 		/* 送信FIFOがに空のとき(UTX[15]==1)送信割り込みであると判断 */
                       119 		/* UTX[15] ->  0: 送信FIFOが空でない, 1: 送信FIFOが空 */
00046a 3639 00FF       120                 move.w UTX1, %d3
       F906            120 
000470 0243 8000       121 		andi.w #0x8000, %d3   |  UTX1と0x8000をAND演算
000474 0C43 0000       122                 cmp.w  #0x0000, %d3   |  
000478 6700 0008       123 		beq    END_interrupt  |  if UTX1[15] == 0 (送信FIFOが空でないとき終了)
00047c 7200            124 		move.l #0, %d1        |  ch = 0 を明示
00047e 4EBA 0004       125 		jsr    INTERPUT       |  送信割り込み時処理
                       126 END_interrupt:
000482 4E73            127 		rte
                       128 
                       129 *************************************
                       130 ** INTERPUT :  送信割り込み時の処理	
                       131 ** 引数     :  %d1.l = チャネル(ch)	
                       132 *************************************
                       133 INTERPUT:
000484 13FC 0033       134                 move.b #'3', LED5/*デバック用*/
       00D0 002B       134 
00048c 46FC 2700       135 		move.w  #0x2700, %SR | 走行レベルを７に設定
000490 0C81 0000       136 		cmpi.l  #0, %d1      | ch = 0 を確認
       0000            136 
000496 6600 002C       137 		bne     END_INTERPUT | if ch != 0 => 復帰
                       138 		/* OUTQ */
00049a 103C 0001       139                 move.b #1, %d0
00049e 4EBA 011E       140 		jsr     OUT_Q    | %d1.b = data
0004a2 0C40 0000       141 		cmpi    #0, %d0      | %d0(OUTQの戻り値) == 0(失敗)
0004a6 6600 000A       142 		bne     TX_DATA      | if so => 送信割り込みをマスク(真下)
0004aa 33FC E108       143 		move.w  #0xe108, USTCNT1
       00FF F900       143 
                       144 TX_DATA:
0004b2 13FC 0034       145 		move.b #'4', LED4/*デバック用*/
       00D0 0029       145 
0004ba 0641 0800       146                 add.w   #0x0800, %d1 | ヘッダを付与
0004be 33C1 00FF       147 		move.w  %d1, UTX1
       F906            147 
                       148 END_INTERPUT:
0004c4 4E75            149 		rts
                       150 
                       151 *************************************
                       152 ** INTERGET  受信割り込みルーチン	
                       153 ** 引数     :  %d1.l = チャネル(ch)	
                       154              **%d2.b = 受信データdata
                       155 **戻り値　なし		
                       156 *************************************
                       157 INTERGET:
0004c6 0C41 0000       158 		cmp #0, %d1 /*(1)*/
0004ca 6600 000A       159 		bne END_INTERGET
0004ce 7000            160 		move.l #0, %d0 /*(2)INQ(引数:d0,d1 戻り値:d0)*/
0004d0 2202            161 		move.l %d2, %d1
0004d2 4EBA 003E       162 		jsr IN_Q
                       163 END_INTERGET:
0004d6 4E75            164 		rts
                       165 
                       166 
                       167 ******************************
                       168 ** キューの初期化
                       169 ******************************
                       170 Init_Q:
0004d8 45F9 0000       171 lea.l top0, %a2
       0000            171 
0004de 47F9 0000       172 lea.l top1, %a3
       0000            172 
0004e4 23CA 0000       173 move.l %a2, out0
       0000            173 
0004ea 23CB 0000       174 move.l %a3, out1
       0000            174 
0004f0 23CA 0000       175 move.l %a2, in0
       0000            175 
0004f6 23CB 0000       176 move.l %a3, in1
       0000            176 
0004fc 23FC 0000       177 move.l #0, s0
       0000 0000       177 
       0000            177 
000506 23FC 0000       178 move.l #0, s1
       0000 0000       178 
       0000            178 
000510 4E75            179 rts
                       180 
                       181 ******************************
                       182 ** INQ
                       183 **入力キュー番号,d0.l 書き込むデータ,d1.b
                       184 **出力 d0,成功1, 失敗0
                       185 ******************************
                       186 IN_Q:		
000512 0C00 0000       187 		cmp.b #0x00, %d0/*noの値で分岐*/
000516 6600 0008       188 		bne i_loop1
00051a 4EBA 000A       189 		jsr INQ0
00051e 4E75            190 		rts
                       191 i_loop1:
000520 4EBA 0050       192 		jsr INQ1
000524 4E75            193 		rts
                       194 
                       195 INQ0:
000526 40E7            196 		move.w %sr, -(%sp)
000528 48E7 00F8       197 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
00052c 46FC 2700       198 		move.w  #0x2700, %SR /*走行レベル7(2)*/
000530 2039 0000       199 		move.l  s0, %d0 /* sの値で実行可能か判別(3) */
       0000            199 
000536 0480 0000       200 		sub.l  #0x100, %d0 /* sが256のときd0を 0x0:失敗 */
       0100            200 
00053c 6700 002C       201 		beq     i0_Finish /* sが0x100でキューが満杯なら終了 */
000540 2279 0000       202 		movea.l in0, %a1 /* 書き込み用のポインタアドレスをa1レジスタへ (4)*/
       0000            202 
000546 12C1            203 		move.b  %d1, (%a1)+ /* データをキューへ入れ、書き込み用ポインタを更新（+2
000548 45F9 0000       204 		lea.l bottom0, %a2/* 次書き込もうとしているアドレスa1とキューデータ領域
       0000            204 
00054e B3CA            205 		cmp.l  %a2, %a1 
000550 6300 000A       206 		bls     i0_STEP1 /* a1 < a2　ならば、そのままSTEP1へ(in++) */
000554 47F9 0000       207 		lea.l top0, %a3 /*in=top*/
       0000            207 
00055a 224B            208 		move.l  %a3, %a1
                       209 i0_STEP1:
00055c 23C9 0000       210 		move.l %a1, in0 
       0000            210 
000562 52B9 0000       211 		add.l #1, s0
       0000            211 
000568 7001            212 		move.l  #1, %d0/* 処理をおこなうことができたのでd0を1に */
                       213 i0_Finish:
00056a 4CDF 1F00       214 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
00056e 46DF            215 		move.w (%sp)+, %sr
000570 4E75            216 		rts /* サブルーチンを抜ける */		
                       217 INQ1:
000572 40E7            218 		move.w %sr,-(%sp)
000574 48E7 00F8       219 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
000578 46FC 2700       220 		move.w  #0x2700, %SR /*走行レベル7(2)*/
00057c 2039 0000       221 		move.l  s1, %d0  /* sの値で実行可能か判別(3) */
       0000            221 
000582 0480 0000       222 		sub.l  #0x100, %d0  /* sが256のときd0を 0x0:失敗 */
       0100            222 
000588 6700 002C       223 		beq     i1_Finish /* 0x100でキューが満杯なら終了 */
00058c 2279 0000       224 		movea.l in1, %a1 /* 書き込み用のポインタアドレスをa1レジスタへ (4)*/
       0000            224 
000592 12C1            225 		move.b  %d1, (%a1)+ /* データをキューへ入れ、書き込み用ポインタを更新（+2
000594 45F9 0000       226 		lea.l bottom1, %a2/* 次書き込もうとしているアドレスa1とキューデータ領域
       0000            226 
00059a B3CA            227 		cmp.l  %a2, %a1 
00059c 6300 000A       228 		bls     i1_STEP1 /* a1 < a2　ならば、そのままSTEP1へ(in++) */
0005a0 47F9 0000       229 		lea.l top1, %a3/*in=top*/
       0000            229 
0005a6 224B            230 		move.l  %a3, %a1
                       231 	
                       232 i1_STEP1:
0005a8 23C9 0000       233 		move.l %a1, in1
       0000            233 
0005ae 52B9 0000       234 		add.l #1, s1
       0000            234 
0005b4 7001            235 		move.l  #1, %d0/* 処理をおこなうことができたのでd0を1に */
                       236 i1_Finish:
0005b6 4CDF 1F00       237 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
0005ba 46DF            238 		move.w (%sp)+, %sr
0005bc 4E75            239 		rts /* サブルーチンを抜ける */
                       240 ******************************
                       241 		** OUTQ
                       242 		**入力:キュー番号:d0.l
                       243 		**出力:d0:0失敗, d0:1成功
                       244 		**取り出したデータ:d1.b
                       245 ******************************
                       246 OUT_Q:		
0005be 0C00 0000       247 		cmp.b #0x00, %d0/*noの値で分岐*/
0005c2 6600 0008       248 		bne o_loop1
0005c6 4EBA 000A       249 		jsr OUTQ0
0005ca 4E75            250 		rts
                       251 o_loop1:
0005cc 4EBA 0050       252 		jsr OUTQ1
0005d0 4E75            253 		rts
                       254 OUTQ0:
0005d2 40E7            255 		move.w %sr,-(%sp)
0005d4 48E7 00F8       256 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
0005d8 46FC 2700       257 		move.w  #0x2700, %SR /*走行レベル7(2)*/
0005dc 2039 0000       258 		move.l  s0, %d0 /* sの値によって実行できるか判定(3) */
       0000            258 
0005e2 0C80 0000       259 		cmp.l  #0x00, %d0 /* sが0のときd0を0x0:失敗  */
       0000            259 
0005e8 6700 002C       260 		beq     o0_Finish /* 0x0でキューが空なら終了 */
0005ec 2279 0000       261 		movea.l out0, %a1 /* 次に取り出すのポインタアドレスをa1レジスタへ (4)*/
       0000            261 
0005f2 1219            262 		move.b  (%a1)+, %d1 /* キューからデータを読み出し、d1に転送 */
0005f4 45F9 0000       263 		lea.l bottom0, %a2 /*次に読み出そうとしているアドレスとキュー領域の末尾
       0000            263 
0005fa B3CA            264 		cmp.l  %a2, %a1 
0005fc 6300 000A       265 		bls     o0_STEP1 /* a1 < a2　ならばSTEP1へ(out++) */
000600 47F9 0000       266 		lea.l top0, %a3 /*out=top*/
       0000            266 
000606 224B            267 		move.l  %a3, %a1
                       268 o0_STEP1:
000608 23C9 0000       269 		move.l %a1, out0
       0000            269 
00060e 53B9 0000       270 		sub.l #1, s0 /*s--*/
       0000            270 
000614 7001            271 		move.l  #1, %d0/* 処理できたのでd0を1に */
                       272 o0_Finish:
000616 4CDF 1F00       273 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
00061a 46DF            274 		move.w (%sp)+, %sr
00061c 4E75            275 		rts /* サブルーチンを抜ける */		
                       276 OUTQ1:
00061e 40E7            277 		move.w %sr,-(%sp)
000620 48E7 00F8       278 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
000624 46FC 2700       279 		move.w  #0x2700, %SR /*走行レベル7(2)*/
000628 2039 0000       280 		move.l  s1, %d0 /* sの値によって実行できるか判定(3) */
       0000            280 
00062e 0C80 0000       281 		cmp.l #0x00, %d0 /* sが0のときd0を0x0:失敗  */
       0000            281 
000634 6700 002C       282 		beq     o1_Finish /* 0x0でキューが空なら終了 */
000638 2279 0000       283 		movea.l out1, %a1 /* 次に取り出すのポインタアドレスをa1レジスタへ (4)*/
       0000            283 
00063e 1219            284 		move.b  (%a1)+, %d1 /* キューからデータを読み出し、d1に転送 */
000640 45F9 0000       285 		lea.l bottom1, %a2/*次に読み出そうとしているアドレスとキュー領域の末尾
       0000            285 
000646 B3CA            286 		cmp.l  %a2, %a1 
000648 6300 000A       287 		bls     o1_STEP1/* a1 < a2　ならばSTEP1へ(out++) */
00064c 47F9 0000       288 		lea.l top1, %a3/*out=top*/
       0000            288 
000652 224B            289 		move.l  %a3, %a1
                       290 o1_STEP1:
000654 23C9 0000       291 		move.l %a1, out1
       0000            291 
00065a 53B9 0000       292 		sub.l #1, s1
       0000            292 
000660 7001            293 		move.l  #1, %d0/* 処理できたのでd0を1に */
                       294 o1_Finish:
000662 4CDF 1F00       295 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
000666 46DF            296 		move.w (%sp)+, %sr
000668 4E75            297 		rts /* サブルーチンを抜ける */
                       298 
                       299 *************************************
                       300 ** PUTSTRING  送信割り込みの処理	
                       301 ** 引数     :  %d1.l = チャネル(ch)	
                       302 **             %d2.l = データ読み込み先の先頭アドレスp いったんa6にさせて
                       303 **             %d3.l = 送信するデータ数size
                       304 ** szはd4レジスタ
                       305 ** iはa5レジスタ
                       306 *************************************
                       307 PUTSTRING:
00066a 0C41 0000       308 		cmp #0x00, %d1
00066e 6600 0046       309 		bne END_PUTSTRING
000672 183C 0000       310 		move.b #0, %d4
000676 4BF9 0000       311 		lea.l TDATA1, %a5 /*デバック用*/
       0000            311 
00067c 0C43 0000       312 		cmp #0, %d3
000680 6700 0032       313 		beq END2_PUTSTRING
                       314 LOOP1_PUTSTRING:
000684 B644            315 		cmp %d4, %d3
000686 6700 001C       316 		beq END3_PUTSTRING
00068a 103C 0001       317 		move.b #1, %d0
00068e 1215            318 		move.b (%a5), %d1
000690 4EBA FE80       319 		jsr IN_Q
000694 0C40 0000       320 		cmp #0, %d0
000698 6700 000A       321                 beq END3_PUTSTRING
00069c 5244            322 		add #1, %d4
00069e 524D            323 		add #1, %a5 
0006a0 6000 FFE2       324 		bra LOOP1_PUTSTRING
                       325 END3_PUTSTRING:
0006a4 13FC 0032       326                  move.b #'2', LED6/*デバック用*/
       00D0 002D       326 
0006ac 33FC E10C       327 		move.w  #0xe10c, USTCNT1
       00FF F900       327 
                       328 END2_PUTSTRING:
0006b4 3004            329 		move %d4, %d0
                       330 END_PUTSTRING:
                       331                 
0006b6 4E75            332 		rts
                       333 *************************************
                       334 ** GETTRING  受信割り込みの処理	
                       335 ** 引数     :  %d1.l = チャネル(ch)	
                       336              **%d2.l = データ書き込み先の先頭アドレスp
                       337              **%d3.l = 取り出すデータ数size
                       338 ** szはd4レジスタ
                       339 ** iはa5レジスタ
                       340 **戻り値　実際に取り出したデータ数sz:%d0.l		
                       341 *************************************
                       342 GETSTRING:
0006b8 0C41 0000       343 		cmp #0, %d1 /*(1)*/
0006bc 6600 0026       344 		bne END_GETSTRING 
0006c0 7800            345 		move.l #0, %d4 /*(2)*/
0006c2 2A42            346 		move.l %d2, %a5
                       347 LOOP1_GETSTRING:	
0006c4 B644            348 		cmp %d4, %d3 /*(3)*/
0006c6 6700 001A       349 		beq END2_GETSTRING
0006ca 103C 0000       350 		move.b #0, %d0 /*(4) d0:成功かどうか, d1:取り出したデータ*/
0006ce 4EBA FEEE       351 		jsr OUT_Q
0006d2 0C40 0000       352 		cmp #0, %d0 /*(5)*/
0006d6 6700 000A       353 		beq END2_GETSTRING
0006da 1AC1            354 		move.b %d1, (%a5)+ /*(6)*/
0006dc 5244            355 		add #1, %d4 /*(7)*/
0006de 6000 FFE4       356 		bra LOOP1_GETSTRING
                       357 END2_GETSTRING:
0006e2 3004            358 		move %d4, %d0
                       359 END_GETSTRING:
0006e4 4E75            360 		rts
                       361 
                       362 
                       363 
                       364 ******************************
                       365 ** RESET_TIMER():	タイマ割り込み→不可、タイマ→停止
                       366 ******************************
                       367 RESET_TIMER:
0006e6 33FC 0004       368 		move.w	#0x0004, TCTL1 /* タイマ1コントロールレジスタに0x0004を設定→割り込
       00FF F600       368 
0006ee 4E75            369 		rts
                       370 
                       371 ******************************
                       372 ** SET_TIMER(t,p):	タイマ割り込み時に呼び出すルーチン設定 
                       373 **			タイマ割り込み周期tを設定（t * 0.1 msec毎に割り込み発生）
                       374 **			タイマ使用およびタイマ割り込み	
                       375 ** 引数 :		t→%d1.w:	タイマの発生周期
                       376 ** 			p→%d2.l	割り込み時に起動するルーチンの先頭アドレス			
                       377 ******************************
                       378 SET_TIMER:
0006f0 23C2 0000       379 		move.l	%d2, task_p /* 割り込み時に起動するルーチンの先頭アドレスpを大域
       0000            379 
0006f6 33FC 0086       380 		move.w	#0206, TPRER1 /* 0.1msec進むとカウンタが1増えるようにする */
       00FF F602       380 
0006fe 33C1 00FF       381 		move.w	%d1, TCMP1 /* t秒周期に設定 */
       F604            381 
000704 33FC 0015       382 		move.w  #0x0015, TCTL1 /* タイマ1コントロールレジスタに0x0015を設定→割り込
       00FF F600       382 
00070c 4E75            383 		rts
                       384 
                       385 ******************************
                       386 ** CALL_RP():	タイマ割り込み時に処理すべきルーチン呼び出し
                       387 ******************************
                       388 CALL_RP:
00070e 48E7 0080       389 		movem.l	%a0, -(%sp)
000712 2079 0000       390 		movea.l task_p, %a0
       0000            390 
000718 4E90            391 		jsr (%a0)
00071a 4CDF 0100       392 		movem.l (%sp)+, %a0
00071e 4E75            393 		rts
                       394 
                       395 
                       396 
                       397 TEST_LIGHT:
000720 13FC 0047       398 		move.b	#'G', LED7
       00D0 002F       398 
000728 13FC 0052       399 		move.b	#'R', LED6
       00D0 002D       399 
000730 13FC 0038       400 		move.b	#'8', LED5
       00D0 002B       400 
000738 13FC 0054       401 		move.b	#'T', LED4
       00D0 0029       401 
000740 13FC 0049       402 		move.b	#'I', LED3
       00D0 003F       402 
000748 13FC 004D       403 		move.b	#'M', LED2
       00D0 003D       403 
000750 13FC 0045       404 		move.b	#'E', LED1
       00D0 003B       404 
000758 13FC 0052       405 		move.b	#'R', LED0
       00D0 0039       405 
000760 4E75            406 		rts
                       407 
                       408 
                       409 
                       410 ******************************
                       411 ** キュー用のメモリ領域確保
                       412 ******************************
                       413 .section .data
                       414 .equ B_SIZE, 256
000798 0000 0000       415 top0:.ds.b B_SIZE-1
       0000 0000       415 
       0000 0000       415 
       0000 0000       415 
       0000 0000       415 
000897 00              416 bottom0:.ds.b 1
000898 0000 0000       417 top1:.ds.b B_SIZE-1
       0000 0000       417 
       0000 0000       417 
       0000 0000       417 
       0000 0000       417 
000997 00              418 bottom1:.ds.b 1
000998 0000 0000       419 out0:.ds.l 1
00099c 0000 0000       420 out1:.ds.l 1
0009a0 0000 0000       421 in0:.ds.l 1
0009a4 0000 0000       422 in1:.ds.l 1
0009a8 0000 0000       423 s0:.ds.l 1                                                      
0009ac 0000 0000       424 s1:.ds.l 1
                       425 /* step5のテスト */
0009b0 3031 3233       426 TDATA1: .ascii "0123456789ABCDEF"
       3435 3637       426 
       3839 4142       426 
       4344 4546       426 
0009c0 6B6C 6D6E       427 TDATA2: .ascii "klmnopqrstuvwxyz"
       6F70 7172       427 
       7374 7576       427 
       7778 797A       427 
                       428 		
                       429 		
                       430 		
                       431 ***************************************************************
                       432 ** 現段階での初期化ルーチンの正常動作を確認するため,最後に ’a’ を
                       433 ** 送信レジスタ UTX1 に書き込む. ’a’ が出力されれば, OK.
                       434 ***************************************************************
                       435 .section .text
                       436 .even
                       437 MAIN:
                       438 	        *move.w #0x0800+'A', UTX1
000762 4EBA FF82       439 		jsr	RESET_TIMER
000766 243C 0000       440 		move.l	#TEST_LIGHT, %d2
       0000            440 
00076c 323C C350       441 		move.w	#50000, %d1
000770 4EBA FF7E       442 		jsr	SET_TIMER
000774 13FC 0047       443 		move.b	#'G', LED7
       00D0 002F       443 
                       444 
                       445 		
                       446 LOOP:
                       447 ******************************
                       448 ** COMPARE_INTERPUT:	タイマ用のハードウェア割り込みインターフェース
                       449 ******************************
                       450 COMPARE_INTERPUT:
00077c 0839 0000       451 		btst	#0, TSTAT1 /* タイマ1ステータスレジスタの0ビット目が0か、否か */
       00FF F60A       451 
000784 6700 000E       452 		beq	COMPARE_END /* 0ならコンペアイベントなし、つまりカウンタ値とコンペ
000788 33FC 0000       453 		move.w	#0x0000, TSTAT1 /* タイマ1ステータスレジスタを0クリア */
       00FF F60A       453 
000790 4EBA FF7C       454 		jsr	CALL_RP /* CALL_RPを呼び出す */
                       455 
                       456 COMPARE_END:
                       457 		*rte
                       458 
000794 6000 FFE6       459 		bra LOOP	
                       460 
