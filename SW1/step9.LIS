                         4 .list
                         5 ***************************************************************
                         6 ** 各種レジスタ定義
                         7 ***************************************************************
                         8 
                         9 ***************
                        10 ** レジスタ群の先頭
                        11 ***************
                        12 .equ REGBASE, 0xFFF000  | DMAP を使用.
                        13 .equ IOBASE,  0x00d00000
                        14 
                        15 ***************
                        16 ** 割り込み関係のレジスタ
                        17 ***************
                        18 .equ IVR,     REGBASE+0x300 | 割り込みベクタレジスタ
                        19 .equ IMR,     REGBASE+0x304 | 割り込みマスクレジスタ
                        20 .equ ISR,     REGBASE+0x30c | 割り込みステータスレジスタ
                        21 .equ IPR,     REGBASE+0x310 | 割り込みペンディングレジスタ
                        22 
                        23 
                        24 ***************
                        25 ** タイマ関係のレジスタ
                        26 ***************
                        27 .equ TCTL1,   REGBASE+0x600 | タイマ1コントロールレジスタ
                        28 .equ TPRER1,  REGBASE+0x602 | タイマ1プリスケーラレジスタ
                        29 .equ TCMP1,   REGBASE+0x604 | タイマ1コンペアレジスタ
                        30 .equ TCN1,    REGBASE+0x608 | タイマ1カウンタレジスタ
                        31 .equ TSTAT1,  REGBASE+0x60a | タイマ1ステータスレジスタ
                        32 ***************
                        33 ** UART1 (送受信)関係のレジスタ
                        34 ***************
                        35 .equ USTCNT1, REGBASE+0x900 | UART1 ステータス / コントロールレジスタ
                        36 .equ UBAUD1,  REGBASE+0x902 | UART1 ボーコントロールレジスタ
                        37 .equ URX1,    REGBASE+0x904 | UART1 受信レジスタ
                        38 .equ UTX1,    REGBASE+0x906 | UART1 送信レジスタ
                        39 ***************
                        40 ** LED
                        41 ***************
                        42 .equ LED7,  IOBASE+0x000002f | ボード搭載のLED用レジスタ
                        43 .equ LED6,  IOBASE+0x000002d | 使用法については付録 A.4.3.1
                        44 .equ LED5,  IOBASE+0x000002b
                        45 .equ LED4,  IOBASE+0x0000029
                        46 .equ LED3,  IOBASE+0x000003f
                        47 .equ LED2,  IOBASE+0x000003d
                        48 .equ LED1,  IOBASE+0x000003b
                        49 .equ LED0,  IOBASE+0x0000039
                        50 
                        51 **************
                        52 **システムコール番号
                        53 **************
                        54 .equ SYSCALL_NUM_GETSTRING,    1
                        55 .equ SYSCALL_NUM_PUTSTRING,    2
                        56 .equ SYSCALL_NUM_RESET_TIMER,  3
                        57 .equ SYSCALL_NUM_SET_TIMER,    4
                        58 
                        59 ***************************************************************
                        60 ** スタック領域の確保
                        61 ***************************************************************
                        62 .section .bss
                        63 .even
                        64 SYS_STK:
000a38 0000 0000        65 		.ds.b  0x4000 | システムスタック領域
       0000 0000        65 
       0000 0000        65 
       0000 0000        65 
       0000 0000        65 
                        66 		.even
                        67 SYS_STK_TOP: 		      | システムスタック領域の最後尾
                        68 
004a38 0000 0000        69 task_p:		.ds.l 1		| タイマ割り込み時に起動するルーチン先頭アドレス代入用
                        70 
                        71 ***************************************************************
                        72 ** 初期化
                        73 ** 内部デバイスレジスタには特定の値が設定されている.
                        74 ** その理由を知るには,付録 B にある各レジスタの仕様を参照すること.
                        75 ***************************************************************
                        76 .section .text
                        77 .even
                        78 boot:
                        79 		* スーパーバイザ & 各種設定を行っている最中の割込禁止
000400 46FC 2700        80 		move.w #0x2700,%SR
000404 4FF9 0000        81 		lea.l SYS_STK_TOP, %SP | Set SSP
       0000             81 
                        82 		****************
                        83 		** 割り込みコントローラの初期化
                        84 		****************
00040a 13FC 0040        85 		move.b #0x40, IVR      | ユーザ割り込みベクタ番号を
       00FF F300        85 
                        86 		                       | 0x40+level に設定.
                        87 		/* 要確認　！！ */
000412 23FC 00FF        88 		move.l #0x00ff3fff,IMR | 全割り込みマスク
       3FFF 00FF        88 
       F304             88 
                        89 		****************
                        90 		** 送受信 (UART1) 関係の初期化 ( 割り込みレベルは 4 に固定されている )
                        91 		****************
00041c 21FC 0000        92 		move.l #UART1_interrupt, 0x110  | 受信割り込みベクタをセット
       0000 0110        92 
000424 33FC 0000        93 		move.w #0x0000, USTCNT1 | リセット
       00FF F900        93 
                        94 		/* バグの原因はここ(下)であることが多い  */
00042c 33FC E10C        95 		move.w #0xe10c, USTCNT1 | 送受信可能 , パリティなし , 1 stop, 8 bit, /* 変更 */
       00FF F900        95 
                        96 					| 受信割り込み許可, 送割り込み禁止
000434 33FC 0038        97 		move.w #0x0038, UBAUD1  | baud rate = 230400 bps
       00FF F902        97 
                        98 		****************
                        99 		** タイマ関係の初期化 ( 割り込みレベルは 6 に固定されている )
                       100 		*****************
00043c 33FC 0004       101 		move.w #0x0004, TCTL1   | restart, 割り込み不可 ,
       00FF F600       101 
                       102 					| システムクロックの 1/16 を単位として計時,
                       103 					| タイマ使用停止
000444 21FC 0000       104 	        move.l #COMPARE_INTERPUT, 0x118 /* level 6 */
       0000 0118       104 
                       105 
00044c 21FC 0000       106                 move.l #SYS_CALL, 0x080 /*SYS_CALLの割り込みベクタ設定*/
       0000 0080       106 
                       107 
                       108 		******************************
                       109 		** キューの初期化
                       110 		******************************
000454 45F9 0000       111 		lea.l  top0, %a2
       0000            111 
00045a 47F9 0000       112 		lea.l  top1, %a3
       0000            112 
000460 23CA 0000       113 		move.l %a2, out0
       0000            113 
000466 23CB 0000       114 		move.l %a3, out1
       0000            114 
00046c 23CA 0000       115 		move.l %a2, in0
       0000            115 
000472 23CB 0000       116 		move.l %a3, in1
       0000            116 
000478 23FC 0000       117 		move.l #0, s0
       0000 0000       117 
       0000            117 
000482 23FC 0000       118 		move.l #0, s1
       0000 0000       118 
       0000            118 
                       119 	
00048c 23FC 00FF       120 		move.l #0x00ff3ff9, IMR
       3FF9 00FF       120 
       F304            120 
000496 6000 0002       121 		bra MAIN
                       122 	
                       123 ****************************************************************
                       124 ***プログラム領域
                       125 ****************************************************************
                       126 .section .text
                       127 .even
                       128 MAIN:
                       129 **走行モードとレベルの設定(「ユーザモード」への移行処理)
00049a 46FC 0000       130 move.w #0x0000, %SR  | USER MODE, LEVEL 0
00049e 4FF9 0000       131 lea.l USR_STK_TOP,%SP  | user stackの設定
       0000            131 
                       132 **システムコールによるRESET_TIMERの起動
0004a4 7003            133 move.l #SYSCALL_NUM_RESET_TIMER,%D0
0004a6 4E40            134 trap   #0
                       135 **システムコールによるSET_TIMERの起動
0004a8 7004            136 move.l #SYSCALL_NUM_SET_TIMER, %D0
0004aa 323C C350       137 move.w #50000, %D1
0004ae 243C 0000       138 move.l #TT,%D2
       0000            138 
0004b4 4E40            139 trap #0
                       140 ******************************
                       141 * sys_GETSTRING, sys_PUTSTRINGのテスト
                       142 *ターミナルの入力をエコーバックする
                       143 ******************************
                       144 LOOP:
0004b6 7001            145 move.l #SYSCALL_NUM_GETSTRING, %D0
0004b8 7200            146 move.l #0,   %D1        | ch    = 0
0004ba 243C 0000       147 move.l #BUF, %D2        | p    = #BUF
       0000            147 
0004c0 263C 0000       148 move.l #256, %D3        | size = 256
       0100            148 
0004c6 4E40            149 trap #0
0004c8 2600            150 move.l %D0, %D3         | size = %D0 (length of given string)
0004ca 7002            151 move.l #SYSCALL_NUM_PUTSTRING, %D0
0004cc 7200            152 move.l #0,  %D1         | ch = 0
0004ce 243C 0000       153 move.l #BUF,%D2         | p  = #BUF
       0000            153 
0004d4 4E40            154 trap #0
0004d6 6000 FFDE       155 bra LOOP
                       156 ******************************
                       157 *タイマのテスト
                       158 * ’******’を表示し改行する．
                       159 *５回実行すると，RESET_TIMERをする．
                       160 ******************************
                       161 TT:
0004da 13FC 0054       162 move.b	#'T', LED3
       00D0 003F       162 
0004e2 13FC 0054       163 move.b	#'T', LED2
       00D0 003D       163 
0004ea 13FC 0054       164 move.b	#'T', LED1
       00D0 003B       164 
0004f2 13FC 0054       165 move.b	#'T', LED0
       00D0 0039       165 
0004fa 48E7 FFFE       166 movem.l %D0-%D7/%A0-%A6,-(%SP)
0004fe 0C79 0005       167 cmpi.w #5,TTC            | TTCカウンタで5回実行したかどうか数える
       0000 0000       167 
000506 6700 0020       168 beq TTKILL               | 5回実行したら，タイマを止める
00050a 6000 FFCE       169 bra TT
00050e 7002            170 move.l #SYSCALL_NUM_PUTSTRING,%D0
000510 7200            171 move.l #0,    %D1        | ch = 0
000512 243C 0000       172 move.l #TMSG, %D2        | p  = #TMSG
       0000            172 
000518 7608            173 move.l #8,    %D3        | size = 8
00051a 4E40            174 trap #0
00051c 0679 0001       175 addi.w #1,TTC            | TTCカウンタを1つ増やして
       0000 0000       175 
000524 6000 0006       176 bra TTEND                |そのまま戻る
                       177 TTKILL:
000528 7003            178 move.l #SYSCALL_NUM_RESET_TIMER,%D0
00052a 4E40            179 trap #0
                       180 TTEND:
00052c 4CDF 7FFF       181 movem.l (%SP)+,%D0-%D7/%A0-%A6
000530 4E75            182 rts
                       183 
                       184 ****************************************************************
                       185 ***初期値のあるデータ領域***************************************************************
                       186 .section .data
                       187 TMSG:
000534 2A2A 2A2A       188 .ascii  "******\r\n"      | \r:行頭へ(キャリッジリターン)
       2A2A 0D0A       188 
                       189 .even                     | \n:次の行へ(ラインフィード)
                       190 TTC:
00053c 0000            191 .dc.w  0
                       192 .even
                       193 
                       194 ****************************************************************
                       195 ***初期値の無いデータ領域***************************************************************
                       196 .section .bss
                       197 BUF:
004a3c 0000 0000       198 .ds.b 256           | BUF[256]
       0000 0000       198 
       0000 0000       198 
       0000 0000       198 
       0000 0000       198 
                       199 .even
                       200 USR_STK:
004b3c 0000 0000       201 .ds.b 0x4000            |ユーザスタック領域
       0000 0000       201 
       0000 0000       201 
       0000 0000       201 
       0000 0000       201 
                       202 .even
                       203 USR_STK_TOP:           |ユーザスタック領域の最後尾		
                       204 
                       205 ******************************
                       206 ** キュー用のメモリ領域確保
                       207 ******************************
                       208 .section .data
                       209 .equ B_SIZE, 256
                       210 top0:
00053e 0000 0000       211 		.ds.b B_SIZE-1
       0000 0000       211 
       0000 0000       211 
       0000 0000       211 
       0000 0000       211 
                       212 bottom0:
00063d 00              213 		.ds.b 1
                       214 top1:
00063e 0000 0000       215 		.ds.b B_SIZE-1
       0000 0000       215 
       0000 0000       215 
       0000 0000       215 
       0000 0000       215 
                       216 bottom1:
00073d 00              217 		.ds.b 1
                       218 out0:
00073e 0000 0000       219 		.ds.l 1
                       220 out1:
000742 0000 0000       221 		.ds.l 1
                       222 in0:
000746 0000 0000       223 		.ds.l 1
                       224 in1:
00074a 0000 0000       225 		.ds.l 1
                       226 s0:
00074e 0000            227 		.ds.w 1
                       228 s1:
000750 0000            229 		.ds.w 1
                       230 
                       231 ******************************
                       232 ** COMPARE_INTERPUT:	タイマ用のハードウェア割り込みインターフェース
                       233 ******************************
                       234 COMPARE_INTERPUT:
000752 48E7 8000       235 		movem.l %d0, -(%sp) /* d0退避 */
000756 3039 00FF       236 		move.w  TSTAT1, %d0 /* TSTATの値をd0へ */
       F60A            236 
00075c 0800 0000       237 		btst	#0, %d0 /* タイマ1ステータスレジスタの0ビット目が0か、否か */
000760 6700 000E       238 		beq	COMPARE_END /* 0ならコンペアイベントなし、つまりカウンタ値とコンペ
000764 33FC 0000       239 		move.w	#0x0000, TSTAT1 /* タイマ1ステータスレジスタを0クリア */
       00FF F60A       239 
00076c 4EBA 0272       240 		jsr	CALL_RP /* CALL_RPを呼び出す */
                       241 
                       242 COMPARE_END:
000770 4CDF 0001       243 		movem.l (%sp)+, %d0 /* d0復帰 */
000774 4E73            244 		rte
                       245 
                       246 *************************************
                       247 ** UART1_interrupt
                       248 ** 送受信割り込みを扱うインターフェース
                       249 *************************************
                       250 /* btst : 指定データの指定ビットが0であるか判断し、0であればCCRのZをセ
                       251 UART1_interrupt:
                       252 		/* 受信FIFOが空でないとき(URX[13]==1)受信割り込みであると判断 */
                       253 		/* URX[13] ->  0: 受信FIFOが空, 1: 受信FIFOが空でない */
000776 3639 00FF       254 		move.w URX1, %d3
       F904            254 
00077c 1403            255 		move.b %d3, %d2       |  %d3.wの下位8bitを%d2.bにコピー
00077e 0803 000D       256 		btst.l #13, %d3       |  13ビット目は受信FIFOにデータが存在するか
000782 6700 000C       257 		beq    CALL_INTERPUT  |  if URX1[13] == 0 (受信FIFOが空のとき)
000786 7200            258 		move.l #0, %d1        |  ch = 0 を明示
000788 4EBA 0020       259 		jsr    INTERGET       |  受信割り込み時処理
00078c 6000 001A       260 		bra    END_interrupt
                       261 CALL_INTERPUT:
                       262 		/* 送信FIFOがに空のとき(UTX[15]==1)送信割り込みであると判断 */
                       263 		/* UTX[15] ->  0: 送信FIFOが空でない, 1: 送信FIFOが空 */
000790 3639 00FF       264         move.w UTX1, %d3
       F906            264 
000796 0839 000F       265 		btst.l #15, UTX1      |  15ビット目は送信FIFOが空であるか
       00FF F906       265 
00079e 6700 0008       266 		beq    END_interrupt  |  if UTX1[15] == 0 (送信FIFOが空でないとき終了)
0007a2 7200            267 		move.l #0, %d1        |  ch = 0 を明示
0007a4 4EBA 0016       268 		jsr    INTERPUT       |  送信割り込み時処理
                       269 END_interrupt:
0007a8 4E73            270 		rte
                       271 
                       272 *************************************
                       273 ** INTERGET  受信割り込みルーチン	
                       274 ** 引数     :  %d1.l = チャネル(ch)	
                       275 **             %d2.b = 受信データdata
                       276 **戻り値　なし		
                       277 *************************************
                       278 INTERGET:
0007aa 0C41 0000       279 		cmp    #0, %d1 /*(1)*/
0007ae 6600 000A       280 		bne    END_INTERGET
0007b2 7000            281 		move.l #0, %d0 /*(2)INQ(引数:d0,d1 戻り値:d0)*/
0007b4 1202            282 		move.b %d2, %d1
0007b6 4EBA 0036       283 		jsr    IN_Q
                       284 END_INTERGET:
0007ba 4E75            285 		rts
                       286 
                       287 *************************************
                       288 ** INTERPUT :  送信割り込み時の処理	
                       289 ** 引数     :  %d1.l = チャネル(ch)	
                       290 *************************************
                       291 INTERPUT:
0007bc 46FC 2700       292 		move.w  #0x2700, %SR | 走行レベルを７に設定
0007c0 0C81 0000       293 		cmpi.l  #0, %d1      | ch = 0 を確認
       0000            293 
0007c6 6600 0024       294 		bne     END_INTERPUT | if ch != 0 => 復帰
0007ca 4EBA 00BE       295 		jsr     OUT_Q        | %d1.b = data
0007ce 0C40 0000       296 		cmpi    #0, %d0      | %d0(OUTQの戻り値) == 0(失敗)
0007d2 6600 000E       297 		bne     TX_DATA      | if so => 送信割り込みをマスク(真下)
0007d6 33FC E108       298 		move.w  #0xe108, USTCNT1
       00FF F900       298 
0007de 6000 000C       299 		bra     END_INTERPUT
                       300 TX_DATA:
0007e2 0641 0800       301 		add.w   #0x0800, %d1 | ヘッダを付与
0007e6 33C1 00FF       302 		move.w  %d1, UTX1
       F906            302 
                       303 END_INTERPUT:
0007ec 4E75            304 		rts
                       305 
                       306 ******************************
                       307 ** INQ
                       308 **入力キュー番号,d0.l 書き込むデータ,d1.b
                       309 **出力 d0,成功1, 失敗0
                       310 ******************************
                       311 IN_Q:		
0007ee 0C00 0000       312 		cmp.b #0x00, %d0/*noの値で分岐*/
0007f2 6600 0008       313 		bne i_loop1
0007f6 4EBA 000A       314 		jsr INQ0
0007fa 4E75            315 		rts
                       316 i_loop1:
0007fc 4EBA 0048       317 		jsr INQ1
000800 4E75            318 		rts
                       319 
                       320 INQ0:
000802 40E7            321 		move.w %sr, -(%sp)
000804 48E7 00F8       322 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
000808 46FC 2700       323 		move.w  #0x2700, %SR /*走行レベル7(2)*/
00080c 303A FF40       324 		move.w  s0, %d0 /* sの値で実行可能か判別(3) */
000810 0440 0100       325 		sub.w  #0x100, %d0 /* sが256のときd0を 0x0:失敗 */
000814 6700 0028       326 		beq     i0_Finish /* sが0x100でキューが満杯なら終了 */
000818 227A FF2C       327 		movea.l in0, %a1 /* 書き込み用のポインタアドレスをa1レジスタへ (4)*/
00081c 12C1            328 		move.b  %d1, (%a1)+ /* データをキューへ入れ、書き込み用ポインタを更新（+2
00081e 45FA FE1D       329 		lea.l bottom0, %a2/* 次書き込もうとしているアドレスa1とキューデータ領域
000822 B3CA            330 		cmp.l  %a2, %a1 
000824 6300 0008       331 		bls     i0_STEP1 /* a1 < a2　ならば、そのままSTEP1へ(in++) */
000828 47FA FD14       332 		lea.l top0, %a3 /*in=top*/
00082c 224B            333 		move.l  %a3, %a1
                       334 i0_STEP1:
00082e 23C9 0000       335 		move.l %a1, in0 
       0000            335 
000834 5279 0000       336 		add.w #1, s0
       0000            336 
00083a 303C 0001       337 		move.w  #1, %d0/* 処理をおこなうことができたのでd0を1に */
                       338 i0_Finish:
00083e 4CDF 1F00       339 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
000842 46DF            340 		move.w (%sp)+, %sr
000844 4E75            341 		rts /* サブルーチンを抜ける */		
                       342 INQ1:
000846 40E7            343 		move.w %sr,-(%sp)
000848 48E7 00F8       344 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
00084c 46FC 2700       345 		move.w  #0x2700, %SR /*走行レベル7(2)*/
000850 303A FEFE       346 		move.w  s1, %d0  /* sの値で実行可能か判別(3) */
000854 0440 0100       347 		sub.w  #0x100, %d0  /* sが256のときd0を 0x0:失敗 */
000858 6700 0028       348 		beq     i1_Finish /* 0x100でキューが満杯なら終了 */
00085c 227A FEEC       349 		movea.l in1, %a1 /* 書き込み用のポインタアドレスをa1レジスタへ (4)*/
000860 12C1            350 		move.b  %d1, (%a1)+ /* データをキューへ入れ、書き込み用ポインタを更新（+2
000862 45FA FED9       351 		lea.l bottom1, %a2/* 次書き込もうとしているアドレスa1とキューデータ領域
000866 B3CA            352 		cmp.l  %a2, %a1 
000868 6300 0008       353 		bls     i1_STEP1 /* a1 < a2　ならば、そのままSTEP1へ(in++) */
00086c 47FA FDD0       354 		lea.l top1, %a3/*in=top*/
000870 224B            355 		move.l  %a3, %a1
                       356 	
                       357 i1_STEP1:
000872 23C9 0000       358 		move.l %a1, in1
       0000            358 
000878 5279 0000       359 		add.w #1, s1
       0000            359 
00087e 303C 0001       360 		move.w  #1, %d0/* 処理をおこなうことができたのでd0を1に */
                       361 i1_Finish:
000882 4CDF 1F00       362 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
000886 46DF            363 		move.w (%sp)+, %sr
000888 4E75            364 		rts /* サブルーチンを抜ける */
                       365 		
                       366 ******************************
                       367 ** OUTQ
                       368 ** 入力:
                       369 **  キュー番号:d0.l
                       370 **      0 -> 受信, 1 -> 送信
                       371 ** 出力:d0:0失敗, d0:1成功
                       372 ** 取り出したデータ:d1.b
                       373 ******************************
                       374 OUT_Q:		
00088a 0C00 0000       375 		cmp.b #0x00, %d0/*noの値で分岐*/
00088e 6600 0008       376 		bne o_loop1
000892 4EBA 000A       377 		jsr OUTQ0
000896 4E75            378 		rts
                       379 o_loop1:
000898 4EBA 0048       380 		jsr OUTQ1
00089c 4E75            381 		rts
                       382 OUTQ0:
00089e 40E7            383 		move.w %sr,-(%sp)
0008a0 48E7 00F8       384 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
0008a4 46FC 2700       385 		move.w  #0x2700, %SR /*走行レベル7(2)*/
0008a8 303A FEA4       386 		move.w  s0, %d0 /* sの値によって実行できるか判定(3) */
0008ac 0C40 0000       387 		cmp.w  #0x00, %d0 /* sが0のときd0を0x0:失敗  */
0008b0 6700 0028       388 		beq     o0_Finish /* 0x0でキューが空なら終了 */
0008b4 227A FE88       389 		movea.l out0, %a1 /* 次に取り出すのポインタアドレスをa1レジスタへ (4)*/
0008b8 1219            390 		move.b  (%a1)+, %d1 /* キューからデータを読み出し、d1に転送 */
0008ba 45FA FD81       391 		lea.l bottom0, %a2 /*次に読み出そうとしているアドレスとキュー領域の末尾
0008be B3CA            392 		cmp.l  %a2, %a1 
0008c0 6300 0008       393 		bls     o0_STEP1 /* a1 < a2　ならばSTEP1へ(out++) */
0008c4 47FA FC78       394 		lea.l top0, %a3 /*out=top*/
0008c8 224B            395 		move.l  %a3, %a1
                       396 o0_STEP1:
0008ca 23C9 0000       397 		move.l %a1, out0
       0000            397 
0008d0 5379 0000       398 		sub.w #1, s0 /*s--*/
       0000            398 
0008d6 303C 0001       399 		move.w  #1, %d0/* 処理できたのでd0を1に */
                       400 o0_Finish:
0008da 4CDF 1F00       401 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
0008de 46DF            402 		move.w (%sp)+, %sr
0008e0 4E75            403 		rts /* サブルーチンを抜ける */		
                       404 OUTQ1:
0008e2 40E7            405 		move.w %sr,-(%sp)
0008e4 48E7 00F8       406 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
0008e8 46FC 2700       407 		move.w  #0x2700, %SR /*走行レベル7(2)*/
0008ec 303A FE62       408 		move.w  s1, %d0 /* sの値によって実行できるか判定(3) */
0008f0 0C40 0000       409 		cmp.w #0x00, %d0 /* sが0のときd0を0x0:失敗  */
0008f4 6700 0028       410 		beq     o1_Finish /* 0x0でキューが空なら終了 */
0008f8 227A FE48       411 		movea.l out1, %a1 /* 次に取り出すのポインタアドレスをa1レジスタへ (4)*/
0008fc 1219            412 		move.b  (%a1)+, %d1 /* キューからデータを読み出し、d1に転送 */
0008fe 45FA FE3D       413 		lea.l bottom1, %a2/*次に読み出そうとしているアドレスとキュー領域の末尾
000902 B3CA            414 		cmp.l  %a2, %a1 
000904 6300 0008       415 		bls     o1_STEP1/* a1 < a2　ならばSTEP1へ(out++) */
000908 47FA FD34       416 		lea.l top1, %a3/*out=top*/
00090c 224B            417 		move.l  %a3, %a1
                       418 o1_STEP1:
00090e 23C9 0000       419 		move.l %a1, out1
       0000            419 
000914 5379 0000       420 		sub.w #1, s1
       0000            420 
00091a 303C 0001       421 		move.w  #1, %d0/* 処理できたのでd0を1に */
                       422 o1_Finish:
00091e 4CDF 1F00       423 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
000922 46DF            424 		move.w (%sp)+, %sr
000924 4E75            425 		rts /* サブルーチンを抜ける */
                       426 
                       427 *************************************
                       428 ** PUTSTRING  送信割り込みの処理	
                       429 ** 引数     :  %d1.l = チャネル(ch)	
                       430 **             %d2.l = データ読み込み先の先頭アドレスp いったんa6にさせて
                       431 **             %d3.l = 送信するデータ数size
                       432 ** szはd4レジスタ
                       433 ** iはa5レジスタ
                       434 *************************************
                       435 PUTSTRING:
000926 0C41 0000       436 		cmp #0, %d1
00092a 6600 003A       437 		bne END_PUTSTRING
00092e 383C 0000       438 		move.w #0, %d4
000932 2A42            439 		move.l %d2, %a5 /**/
000934 0C43 0000       440 		cmp #0, %d3
000938 6700 002A       441 		beq END2_PUTSTRING
                       442 LOOP1_PUTSTRING:
00093c B644            443 		cmp %d4, %d3
00093e 6700 001C       444 		beq END3_PUTSTRING
000942 103C 0001       445 		move.b #1, %d0
000946 1215            446 		move.b (%a5), %d1
000948 4EBA FEA4       447 		jsr IN_Q
00094c 0C40 0000       448 		cmp #0, %d0
000950 6700 000A       449                 beq END3_PUTSTRING
000954 5244            450 		add #1, %d4
000956 524D            451 		add #1, %a5 
000958 6000 FFE2       452 		bra LOOP1_PUTSTRING
                       453 END3_PUTSTRING:
                       454                 
00095c 33FC E10C       455 		move.w  #0xe10c, USTCNT1
       00FF F900       455 
                       456 END2_PUTSTRING:
000964 3004            457 		move %d4, %d0
                       458 END_PUTSTRING:
000966 4E75            459 		rts
                       460 
                       461 
                       462 		
                       463 *************************************
                       464 ** GETSTRING  受信割り込みの処理	
                       465 ** 引数     :  %d1.l = チャネル(ch)
                       466 ** 	       %d2.l = データ書き込み先の先頭アドレスp
                       467 **             %d3.l = 取り出すデータ数size
                       468 ** szはd4レジスタ
                       469 ** iはa5レジスタ
                       470 **戻り値　実際に取り出したデータ数sz:%d0.l		
                       471 *************************************
                       472 GETSTRING:
000968 0C41 0000       473 		cmp    #0, %d1 /*(1)*/
00096c 6600 0028       474 		bne    END_GETSTRING 
000970 383C 0000       475 		move.w #0, %d4 /*(2)*/
000974 2A42            476 		move.l %d2, %a5
                       477 LOOP1_GETSTRING:	
000976 B644            478 		cmp    %d4, %d3 /*(3)*/
000978 6700 001A       479 		beq    END2_GETSTRING
00097c 103C 0000       480 		move.b #0, %d0 /*(4) d0:成功かどうか, d1:取り出したデータ*/
000980 4EBA FF08       481 		jsr    OUT_Q
000984 0C40 0000       482 		cmp    #0, %d0 /*(5)*/
000988 6700 000A       483 		beq    END2_GETSTRING
00098c 1AC1            484 		move.b %d1, (%a5)+ /*(6)*/
00098e 5244            485 		add    #1, %d4 /*(7)*/
000990 6000 FFE4       486 		bra    LOOP1_GETSTRING
                       487 END2_GETSTRING:
000994 3004            488 		move   %d4, %d0
                       489 END_GETSTRING:
000996 4E75            490 		rts
                       491 
                       492 ******************************
                       493 ** RESET_TIMER():	タイマ割り込み→不可、タイマ→停止
                       494 ******************************
                       495 RESET_TIMER:
000998 33FC 0004       496 		move.w	#0x0004, TCTL1 /* タイマ1コントロールレジスタに0x0004を設定→割り込
       00FF F600       496 
0009a0 4E75            497 		rts
                       498 		
                       499 ******************************
                       500 ** SET_TIMER(t,p):	タイマ割り込み時に呼び出すルーチン設定 
                       501 **			タイマ割り込み周期tを設定（t * 0.1 msec毎に割り込み発生）
                       502 **			タイマ使用およびタイマ割り込み	
                       503 ** 引数 :		t→%d1.w:	タイマの発生周期
                       504 ** 			p→%d2.l	割り込み時に起動するルーチンの先頭アドレス			
                       505 ******************************
                       506 SET_TIMER:
0009a2 23C2 0000       507 		move.l	%d2, task_p /* 割り込み時に起動するルーチンの先頭アドレスpを大域
       0000            507 
0009a8 33FC 0086       508 		move.w	#0206, TPRER1 /* 0.1msec進むとカウンタが1増えるようにする */
       00FF F602       508 
0009b0 33C1 00FF       509 		move.w	%d1, TCMP1 /* t秒周期に設定 */
       F604            509 
0009b6 33FC 0015       510 		move.w  #0x0015, TCTL1 /* タイマ1コントロールレジスタに0x0015を設定→割り込
       00FF F600       510 
0009be 13FC 0074       511 		move.b	#'t', LED7
       00D0 002F       511 
0009c6 13FC 0065       512 		move.b	#'e', LED6
       00D0 002D       512 
0009ce 13FC 0073       513 		move.b	#'s', LED5
       00D0 002B       513 
0009d6 13FC 0074       514 		move.b	#'t', LED4	
       00D0 0029       514 
0009de 4E75            515 		rts
                       516 
                       517 ******************************
                       518 ** CALL_RP():	タイマ割り込み時に処理すべきルーチン呼び出し
                       519 ******************************
                       520 CALL_RP:
0009e0 48E7 0080       521 		movem.l	%a0, -(%sp)
0009e4 2079 0000       522 		movea.l task_p, %a0
       0000            522 
0009ea 4E90            523 		jsr (%a0)
0009ec 4CDF 0100       524 		movem.l (%sp)+, %a0
0009f0 4E75            525 		rts
                       526 
                       527 *******************************************
                       528 ** システムコールインターフェース
                       529 ** 入力：
                       530 **　　　　システムコール番号   : %d0.l
                       531 **　　　　システムコールの引数 : %d1以降
                       532 ** 出力：
                       533 **　　　　システムコール呼び出しの結果 : %d0.l
                       534 ** ========================================		
                       535 **        +---+---------------+
                       536 **        | 1 | GETSTRING     |
                       537 **        | 2 | PUTSTRING     |
                       538 **        | 3 | RESET_TIMER   |
                       539 **        | 4 | SET_TIMER     |
                       540 **        +---+---------------+
                       541 *******************************************
                       542 SYS_CALL:
                       543 		
                       544 CALL_1:		
0009f2 0C80 0000       545 		cmpi.l #1, %d0   | コール番号の確認(no.1)
       0001            545 
0009f8 6600 000A       546 		bne    CALL_2    | 異なれば他のコール番号の確認
0009fc 4EBA FF6A       547 		jsr    GETSTRING | 対応するシステムコールを呼び出し
000a00 6000 0034       548                 bra    END_SYS_CALL
                       549 CALL_2:
000a04 0C80 0000       550 		cmpi.l #2, %d0
       0002            550 
000a0a 6600 000A       551 		bne    CALL_3
000a0e 4EBA FF16       552 		jsr    PUTSTRING
000a12 6000 0022       553                 bra    END_SYS_CALL
                       554 CALL_3:
000a16 0C80 0000       555 		cmpi.l #3, %d0
       0003            555 
000a1c 6600 000A       556 		bne    CALL_4
000a20 4EBA FF76       557 		jsr    RESET_TIMER
000a24 6000 0010       558                 bra    END_SYS_CALL
                       559 CALL_4:
000a28 0C80 0000       560 		cmpi.l #4, %d0
       0004            560 
000a2e 6600 0006       561 		bne    END_SYS_CALL
000a32 4EBA FF6E       562 		jsr    SET_TIMER
                       563 END_SYS_CALL:	
000a36 4E73            564 		rte		
