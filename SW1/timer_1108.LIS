                         4 .list
                         5 ***************************************************************
                         6 ** 各種レジスタ定義
                         7 ***************************************************************
                         8 
                         9 ***************
                        10 ** レジスタ群の先頭
                        11 ***************
                        12 .equ REGBASE, 0xFFF000  | DMAP を使用.
                        13 .equ IOBASE,  0x00d00000
                        14 
                        15 ***************
                        16 ** 割り込み関係のレジスタ
                        17 ***************
                        18 .equ IVR,     REGBASE+0x300 | 割り込みベクタレジスタ
                        19 .equ IMR,     REGBASE+0x304 | 割り込みマスクレジスタ
                        20 .equ ISR,     REGBASE+0x30c | 割り込みステータスレジスタ
                        21 .equ IPR,     REGBASE+0x310 | 割り込みペンディングレジスタ
                        22 
                        23 
                        24 ***************
                        25 ** タイマ関係のレジスタ
                        26 ***************
                        27 .equ TCTL1,   REGBASE+0x600 | タイマ1コントロールレジスタ
                        28 .equ TPRER1,  REGBASE+0x602 | タイマ1プリスケーラレジスタ
                        29 .equ TCMP1,   REGBASE+0x604 | タイマ1コンペアレジスタ
                        30 .equ TCN1,    REGBASE+0x608 | タイマ1カウンタレジスタ
                        31 .equ TSTAT1,  REGBASE+0x60a | タイマ1ステータスレジスタ
                        32 ***************
                        33 ** UART1 (送受信)関係のレジスタ
                        34 ***************
                        35 .equ USTCNT1, REGBASE+0x900 | UART1 ステータス / コントロールレジスタ
                        36 .equ UBAUD1,  REGBASE+0x902 | UART1 ボーコントロールレジスタ
                        37 .equ URX1,    REGBASE+0x904 | UART1 受信レジスタ
                        38 .equ UTX1,    REGBASE+0x906 | UART1 送信レジスタ
                        39 ***************
                        40 ** LED
                        41 ***************
                        42 .equ LED7,  IOBASE+0x000002f | ボード搭載のLED用レジスタ
                        43 .equ LED6,  IOBASE+0x000002d | 使用法については付録 A.4.3.1
                        44 .equ LED5,  IOBASE+0x000002b
                        45 .equ LED4,  IOBASE+0x0000029
                        46 .equ LED3,  IOBASE+0x000003f
                        47 .equ LED2,  IOBASE+0x000003d
                        48 .equ LED1,  IOBASE+0x000003b
                        49 .equ LED0,  IOBASE+0x0000039
                        50 
                        51 ***************************************************************
                        52 ** スタック領域の確保
                        53 ***************************************************************
                        54 .section .bss
                        55 .even
                        56 SYS_STK:
0009ec 0000 0000        57 		.ds.b  0x4000 | システムスタック領域
       0000 0000        57 
       0000 0000        57 
       0000 0000        57 
       0000 0000        57 
                        58 		.even
                        59 SYS_STK_TOP: 		      | システムスタック領域の最後尾
                        60 
0049ec 0000 0000        61 task_p:		.ds.l 1		| タイマ割り込み時に起動するルーチン先頭アドレス代入用
                        62 
                        63 ***************************************************************
                        64 ** 初期化
                        65 ** 内部デバイスレジスタには特定の値が設定されている.
                        66 ** その理由を知るには,付録 B にある各レジスタの仕様を参照すること.
                        67 ***************************************************************
                        68 .section .text
                        69 .even
                        70 boot:
                        71 		* スーパーバイザ & 各種設定を行っている最中の割込禁止
000400 46FC 2000        72 		move.w #0x2000,%SR /* superviser-mode level 0 */
000404 4FF9 0000        73 		lea.l SYS_STK_TOP, %SP | Set SSP
       0000             73 
                        74 		****************
                        75 		** 割り込みコントローラの初期化
                        76 		****************
00040a 13FC 0040        77 		move.b #0x40, IVR      | ユーザ割り込みベクタ番号を
       00FF F300        77 
                        78 		                       | 0x40+level に設定.
000412 23FC 00FF        79 		move.l #0x00ff3ff9,IMR | 全割り込みマスク
       3FF9 00FF        79 
       F304             79 
                        80 		****************
                        81 		** 送受信 (UART1) 関係の初期化 ( 割り込みレベルは 4 に固定されている )
                        82 		****************
00041c 21FC 0000        83 		move.l #UART1_interrupt, 0x110  | 受信割り込みベクタをセット
       0000 0110        83 
000424 33FC 0000        84 		move.w #0x0000, USTCNT1 | リセット
       00FF F900        84 
                        85 		/* バグの原因はここ(下)であることが多い  */
00042c 33FC E108        86 		move.w #0xe108, USTCNT1 | 送受信可能 , パリティなし , 1 stop, 8 bit, /* 変更 */
       00FF F900        86 
                        87 					| 受信割り込み許可, 送割り込み禁止
000434 33FC 0038        88 		move.w #0x0038, UBAUD1  | baud rate = 230400 bps
       00FF F902        88 
                        89 		****************
                        90 		** タイマ関係の初期化 ( 割り込みレベルは 6 に固定されている )
                        91 		*****************
00043c 33FC 0004        92 		move.w #0x0004, TCTL1   | restart, 割り込み不可 ,
       00FF F600        92 
                        93 					| システムクロックの 1/16 を単位として計時,
                        94 					| タイマ使用停止
000444 21FC 0000        95 		move.l #COMPARE_INTERPUT, 0x118 /* level 6 */
       0000 0118        95 
                        96                 
00044c 4EBA 00A4        97                 jsr Init_Q              | キューの初期化 
000450 6000 034A        98 		bra MAIN
                        99 
                       100 ******************************
                       101 ** COMPARE_INTERPUT:	タイマ用のハードウェア割り込みインターフェース
                       102 ******************************
                       103 COMPARE_INTERPUT:
000454 48E7 8000       104 		movem.l %d0, -(%sp) /* d0退避 */
000458 3039 00FF       105 		move.w  TSTAT1, %d0 /* TSTATの値をd0へ */
       F60A            105 
00045e 0800 0000       106 		btst	#0, %d0 /* タイマ1ステータスレジスタの0ビット目が0か、否か */
000462 6700 000E       107 		beq	COMPARE_END /* 0ならコンペアイベントなし、つまりカウンタ値とコンペ
000466 33FC 0000       108 		move.w	#0x0000, TSTAT1 /* タイマ1ステータスレジスタを0クリア */
       00FF F60A       108 
00046e 4EBA 02D8       109 		jsr	CALL_RP /* CALL_RPを呼び出す */
                       110 
                       111 COMPARE_END:
                       112 		*rte
000472 4CDF 0001       113 		movem.l (%sp)+, %d0 /* d0復帰 */
                       114 
                       115 *************************************
                       116 ** UART1_interrupt
                       117 ** 送受信割り込みを扱うインターフェース
                       118 ** #0d8192 = 0b0010_0000_0000_0000
                       119 ** #0x8000 = 0b1000_0000_0000_0000
                       120 *************************************
                       121 /* btst : 指定データの指定ビットが0であるか判断し、0であればCCRのZに0を
                       122 UART1_interrupt:
                       123 		/* 受信FIFOが空でないとき(URX[13]==1)受信割り込みであると判断 */
                       124 		/* URX[13] ->  0: 受信FIFOが空, 1: 受信FIFOが空でない */
000476 3639 00FF       125 		move.w URX1, %d3
       F904            125 
00047c 1403            126 		move.b %d3, %d2       |  %d3.wの下位8bitを%d2.bにコピー
00047e 0243 2000       127                 andi.w #8192, %d3     |  URX1と#8192をAND演算
000482 0C43 0000       128 		cmpi.w #0, %d3        |  
000486 6700 000C       129 		beq    CALL_INTERPUT  |  if URX1[13] == 0 (受信FIFOが空のとき)
00048a 7200            130 		move.l #0, %d1        |  ch = 0 を明示
00048c 4EBA 0052       131 		jsr    INTERGET       |  受信割り込み時処理
000490 6000 001A       132 		bra    END_interrupt
                       133 CALL_INTERPUT:
                       134 		/* 送信FIFOがに空のとき(UTX[15]==1)送信割り込みであると判断 */
                       135 		/* UTX[15] ->  0: 送信FIFOが空でない, 1: 送信FIFOが空 */
000494 3639 00FF       136                 move.w UTX1, %d3
       F906            136 
00049a 0243 8000       137 		andi.w #0x8000, %d3   |  UTX1と0x8000をAND演算
00049e 0C43 0000       138                 cmp.w  #0x0000, %d3   |  
0004a2 6700 0008       139 		beq    END_interrupt  |  if UTX1[15] == 0 (送信FIFOが空でないとき終了)
0004a6 7200            140 		move.l #0, %d1        |  ch = 0 を明示
0004a8 4EBA 0004       141 		jsr    INTERPUT       |  送信割り込み時処理
                       142 END_interrupt:
0004ac 4E73            143 		rte
                       144 
                       145 *************************************
                       146 ** INTERPUT :  送信割り込み時の処理	
                       147 ** 引数     :  %d1.l = チャネル(ch)	
                       148 *************************************
                       149 INTERPUT:
                       150                 *move.b #'3', LED5/*デバック用*/
0004ae 46FC 2700       151 		move.w  #0x2700, %SR | 走行レベルを７に設定
0004b2 0C81 0000       152 		cmpi.l  #0, %d1      | ch = 0 を確認
       0000            152 
0004b8 6600 0024       153 		bne     END_INTERPUT | if ch != 0 => 復帰
                       154 		/* OUTQ */
0004bc 103C 0001       155                 move.b #1, %d0
0004c0 4EBA 0116       156 		jsr     OUT_Q    | %d1.b = data
0004c4 0C40 0000       157 		cmpi    #0, %d0      | %d0(OUTQの戻り値) == 0(失敗)
0004c8 6600 000A       158 		bne     TX_DATA      | if so => 送信割り込みをマスク(真下)
0004cc 33FC E108       159 		move.w  #0xe108, USTCNT1
       00FF F900       159 
                       160 TX_DATA:
                       161 		*move.b #'4', LED4/*デバック用*/
0004d4 0641 0800       162                 add.w   #0x0800, %d1 | ヘッダを付与
0004d8 33C1 00FF       163 		move.w  %d1, UTX1
       F906            163 
                       164 END_INTERPUT:
0004de 4E75            165 		rts
                       166 
                       167 *************************************
                       168 ** INTERGET  受信割り込みルーチン	
                       169 ** 引数     :  %d1.l = チャネル(ch)	
                       170              **%d2.b = 受信データdata
                       171 **戻り値　なし		
                       172 *************************************
                       173 INTERGET:
0004e0 0C41 0000       174 		cmp #0, %d1 /*(1)*/
0004e4 6600 000A       175 		bne END_INTERGET
0004e8 7000            176 		move.l #0, %d0 /*(2)INQ(引数:d0,d1 戻り値:d0)*/
0004ea 2202            177 		move.l %d2, %d1
0004ec 4EBA 003E       178 		jsr IN_Q
                       179 END_INTERGET:
0004f0 4E75            180 		rts
                       181 
                       182 
                       183 ******************************
                       184 ** キューの初期化
                       185 ******************************
                       186 Init_Q:
0004f2 45F9 0000       187 lea.l top0, %a2
       0000            187 
0004f8 47F9 0000       188 lea.l top1, %a3
       0000            188 
0004fe 23CA 0000       189 move.l %a2, out0
       0000            189 
000504 23CB 0000       190 move.l %a3, out1
       0000            190 
00050a 23CA 0000       191 move.l %a2, in0
       0000            191 
000510 23CB 0000       192 move.l %a3, in1
       0000            192 
000516 23FC 0000       193 move.l #0, s0
       0000 0000       193 
       0000            193 
000520 23FC 0000       194 move.l #0, s1
       0000 0000       194 
       0000            194 
00052a 4E75            195 rts
                       196 
                       197 ******************************
                       198 ** INQ
                       199 **入力キュー番号,d0.l 書き込むデータ,d1.b
                       200 **出力 d0,成功1, 失敗0
                       201 ******************************
                       202 IN_Q:		
00052c 0C00 0000       203 		cmp.b #0x00, %d0/*noの値で分岐*/
000530 6600 0008       204 		bne i_loop1
000534 4EBA 000A       205 		jsr INQ0
000538 4E75            206 		rts
                       207 i_loop1:
00053a 4EBA 0050       208 		jsr INQ1
00053e 4E75            209 		rts
                       210 
                       211 INQ0:
000540 40E7            212 		move.w %sr, -(%sp)
000542 48E7 00F8       213 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
000546 46FC 2700       214 		move.w  #0x2700, %SR /*走行レベル7(2)*/
00054a 2039 0000       215 		move.l  s0, %d0 /* sの値で実行可能か判別(3) */
       0000            215 
000550 0480 0000       216 		sub.l  #0x100, %d0 /* sが256のときd0を 0x0:失敗 */
       0100            216 
000556 6700 002C       217 		beq     i0_Finish /* sが0x100でキューが満杯なら終了 */
00055a 2279 0000       218 		movea.l in0, %a1 /* 書き込み用のポインタアドレスをa1レジスタへ (4)*/
       0000            218 
000560 12C1            219 		move.b  %d1, (%a1)+ /* データをキューへ入れ、書き込み用ポインタを更新（+2
000562 45F9 0000       220 		lea.l bottom0, %a2/* 次書き込もうとしているアドレスa1とキューデータ領域
       0000            220 
000568 B3CA            221 		cmp.l  %a2, %a1 
00056a 6300 000A       222 		bls     i0_STEP1 /* a1 < a2　ならば、そのままSTEP1へ(in++) */
00056e 47F9 0000       223 		lea.l top0, %a3 /*in=top*/
       0000            223 
000574 224B            224 		move.l  %a3, %a1
                       225 i0_STEP1:
000576 23C9 0000       226 		move.l %a1, in0 
       0000            226 
00057c 52B9 0000       227 		add.l #1, s0
       0000            227 
000582 7001            228 		move.l  #1, %d0/* 処理をおこなうことができたのでd0を1に */
                       229 i0_Finish:
000584 4CDF 1F00       230 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
000588 46DF            231 		move.w (%sp)+, %sr
00058a 4E75            232 		rts /* サブルーチンを抜ける */		
                       233 INQ1:
00058c 40E7            234 		move.w %sr,-(%sp)
00058e 48E7 00F8       235 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
000592 46FC 2700       236 		move.w  #0x2700, %SR /*走行レベル7(2)*/
000596 2039 0000       237 		move.l  s1, %d0  /* sの値で実行可能か判別(3) */
       0000            237 
00059c 0480 0000       238 		sub.l  #0x100, %d0  /* sが256のときd0を 0x0:失敗 */
       0100            238 
0005a2 6700 002C       239 		beq     i1_Finish /* 0x100でキューが満杯なら終了 */
0005a6 2279 0000       240 		movea.l in1, %a1 /* 書き込み用のポインタアドレスをa1レジスタへ (4)*/
       0000            240 
0005ac 12C1            241 		move.b  %d1, (%a1)+ /* データをキューへ入れ、書き込み用ポインタを更新（+2
0005ae 45F9 0000       242 		lea.l bottom1, %a2/* 次書き込もうとしているアドレスa1とキューデータ領域
       0000            242 
0005b4 B3CA            243 		cmp.l  %a2, %a1 
0005b6 6300 000A       244 		bls     i1_STEP1 /* a1 < a2　ならば、そのままSTEP1へ(in++) */
0005ba 47F9 0000       245 		lea.l top1, %a3/*in=top*/
       0000            245 
0005c0 224B            246 		move.l  %a3, %a1
                       247 	
                       248 i1_STEP1:
0005c2 23C9 0000       249 		move.l %a1, in1
       0000            249 
0005c8 52B9 0000       250 		add.l #1, s1
       0000            250 
0005ce 7001            251 		move.l  #1, %d0/* 処理をおこなうことができたのでd0を1に */
                       252 i1_Finish:
0005d0 4CDF 1F00       253 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
0005d4 46DF            254 		move.w (%sp)+, %sr
0005d6 4E75            255 		rts /* サブルーチンを抜ける */
                       256 ******************************
                       257 		** OUTQ
                       258 		**入力:キュー番号:d0.l
                       259 		**出力:d0:0失敗, d0:1成功
                       260 		**取り出したデータ:d1.b
                       261 ******************************
                       262 OUT_Q:		
0005d8 0C00 0000       263 		cmp.b #0x00, %d0/*noの値で分岐*/
0005dc 6600 0008       264 		bne o_loop1
0005e0 4EBA 000A       265 		jsr OUTQ0
0005e4 4E75            266 		rts
                       267 o_loop1:
0005e6 4EBA 0050       268 		jsr OUTQ1
0005ea 4E75            269 		rts
                       270 OUTQ0:
0005ec 40E7            271 		move.w %sr,-(%sp)
0005ee 48E7 00F8       272 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
0005f2 46FC 2700       273 		move.w  #0x2700, %SR /*走行レベル7(2)*/
0005f6 2039 0000       274 		move.l  s0, %d0 /* sの値によって実行できるか判定(3) */
       0000            274 
0005fc 0C80 0000       275 		cmp.l  #0x00, %d0 /* sが0のときd0を0x0:失敗  */
       0000            275 
000602 6700 002C       276 		beq     o0_Finish /* 0x0でキューが空なら終了 */
000606 2279 0000       277 		movea.l out0, %a1 /* 次に取り出すのポインタアドレスをa1レジスタへ (4)*/
       0000            277 
00060c 1219            278 		move.b  (%a1)+, %d1 /* キューからデータを読み出し、d1に転送 */
00060e 45F9 0000       279 		lea.l bottom0, %a2 /*次に読み出そうとしているアドレスとキュー領域の末尾
       0000            279 
000614 B3CA            280 		cmp.l  %a2, %a1 
000616 6300 000A       281 		bls     o0_STEP1 /* a1 < a2　ならばSTEP1へ(out++) */
00061a 47F9 0000       282 		lea.l top0, %a3 /*out=top*/
       0000            282 
000620 224B            283 		move.l  %a3, %a1
                       284 o0_STEP1:
000622 23C9 0000       285 		move.l %a1, out0
       0000            285 
000628 53B9 0000       286 		sub.l #1, s0 /*s--*/
       0000            286 
00062e 7001            287 		move.l  #1, %d0/* 処理できたのでd0を1に */
                       288 o0_Finish:
000630 4CDF 1F00       289 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
000634 46DF            290 		move.w (%sp)+, %sr
000636 4E75            291 		rts /* サブルーチンを抜ける */		
                       292 OUTQ1:
000638 40E7            293 		move.w %sr,-(%sp)
00063a 48E7 00F8       294 		movem.l %a0-%a4,-(%sp) /* レジスタ退避(1) */
00063e 46FC 2700       295 		move.w  #0x2700, %SR /*走行レベル7(2)*/
000642 2039 0000       296 		move.l  s1, %d0 /* sの値によって実行できるか判定(3) */
       0000            296 
000648 0C80 0000       297 		cmp.l #0x00, %d0 /* sが0のときd0を0x0:失敗  */
       0000            297 
00064e 6700 002C       298 		beq     o1_Finish /* 0x0でキューが空なら終了 */
000652 2279 0000       299 		movea.l out1, %a1 /* 次に取り出すのポインタアドレスをa1レジスタへ (4)*/
       0000            299 
000658 1219            300 		move.b  (%a1)+, %d1 /* キューからデータを読み出し、d1に転送 */
00065a 45F9 0000       301 		lea.l bottom1, %a2/*次に読み出そうとしているアドレスとキュー領域の末尾
       0000            301 
000660 B3CA            302 		cmp.l  %a2, %a1 
000662 6300 000A       303 		bls     o1_STEP1/* a1 < a2　ならばSTEP1へ(out++) */
000666 47F9 0000       304 		lea.l top1, %a3/*out=top*/
       0000            304 
00066c 224B            305 		move.l  %a3, %a1
                       306 o1_STEP1:
00066e 23C9 0000       307 		move.l %a1, out1
       0000            307 
000674 53B9 0000       308 		sub.l #1, s1
       0000            308 
00067a 7001            309 		move.l  #1, %d0/* 処理できたのでd0を1に */
                       310 o1_Finish:
00067c 4CDF 1F00       311 		movem.l (%sp)+, %a0-%a4 /* レジスタ復帰 */
000680 46DF            312 		move.w (%sp)+, %sr
000682 4E75            313 		rts /* サブルーチンを抜ける */
                       314 
                       315 *************************************
                       316 ** PUTSTRING  送信割り込みの処理	
                       317 ** 引数     :  %d1.l = チャネル(ch)	
                       318 **             %d2.l = データ読み込み先の先頭アドレスp いったんa6にさせて
                       319 **             %d3.l = 送信するデータ数size
                       320 ** szはd4レジスタ
                       321 ** iはa5レジスタ
                       322 *************************************
                       323 PUTSTRING:
000684 0C41 0000       324 		cmp #0x00, %d1
000688 6600 0046       325 		bne END_PUTSTRING
00068c 183C 0000       326 		move.b #0, %d4
000690 4BF9 0000       327 		lea.l TDATA1, %a5 /*デバック用*/
       0000            327 
000696 0C43 0000       328 		cmp #0, %d3
00069a 6700 0032       329 		beq END2_PUTSTRING
                       330 LOOP1_PUTSTRING:
00069e B644            331 		cmp %d4, %d3
0006a0 6700 001C       332 		beq END3_PUTSTRING
0006a4 103C 0001       333 		move.b #1, %d0
0006a8 1215            334 		move.b (%a5), %d1
0006aa 4EBA FE80       335 		jsr IN_Q
0006ae 0C40 0000       336 		cmp #0, %d0
0006b2 6700 000A       337                 beq END3_PUTSTRING
0006b6 5244            338 		add #1, %d4
0006b8 524D            339 		add #1, %a5 
0006ba 6000 FFE2       340 		bra LOOP1_PUTSTRING
                       341 END3_PUTSTRING:
0006be 13FC 0032       342                  move.b #'2', LED6/*デバック用*/
       00D0 002D       342 
0006c6 33FC E10C       343 		move.w  #0xe10c, USTCNT1
       00FF F900       343 
                       344 END2_PUTSTRING:
0006ce 3004            345 		move %d4, %d0
                       346 END_PUTSTRING:
                       347                 
0006d0 4E75            348 		rts
                       349 *************************************
                       350 ** GETTRING  受信割り込みの処理	
                       351 ** 引数     :  %d1.l = チャネル(ch)	
                       352              **%d2.l = データ書き込み先の先頭アドレスp
                       353              **%d3.l = 取り出すデータ数size
                       354 ** szはd4レジスタ
                       355 ** iはa5レジスタ
                       356 **戻り値　実際に取り出したデータ数sz:%d0.l		
                       357 *************************************
                       358 GETSTRING:
0006d2 0C41 0000       359 		cmp #0, %d1 /*(1)*/
0006d6 6600 0026       360 		bne END_GETSTRING 
0006da 7800            361 		move.l #0, %d4 /*(2)*/
0006dc 2A42            362 		move.l %d2, %a5
                       363 LOOP1_GETSTRING:	
0006de B644            364 		cmp %d4, %d3 /*(3)*/
0006e0 6700 001A       365 		beq END2_GETSTRING
0006e4 103C 0000       366 		move.b #0, %d0 /*(4) d0:成功かどうか, d1:取り出したデータ*/
0006e8 4EBA FEEE       367 		jsr OUT_Q
0006ec 0C40 0000       368 		cmp #0, %d0 /*(5)*/
0006f0 6700 000A       369 		beq END2_GETSTRING
0006f4 1AC1            370 		move.b %d1, (%a5)+ /*(6)*/
0006f6 5244            371 		add #1, %d4 /*(7)*/
0006f8 6000 FFE4       372 		bra LOOP1_GETSTRING
                       373 END2_GETSTRING:
0006fc 3004            374 		move %d4, %d0
                       375 END_GETSTRING:
0006fe 4E75            376 		rts
                       377 
                       378 
                       379 
                       380 ******************************
                       381 ** RESET_TIMER():	タイマ割り込み→不可、タイマ→停止
                       382 ******************************
                       383 RESET_TIMER:
000700 33FC 0004       384 		move.w	#0x0004, TCTL1 /* タイマ1コントロールレジスタに0x0004を設定→割り込
       00FF F600       384 
000708 4E75            385 		rts
                       386 
                       387 ******************************
                       388 ** SET_TIMER(t,p):	タイマ割り込み時に呼び出すルーチン設定 
                       389 **			タイマ割り込み周期tを設定（t * 0.1 msec毎に割り込み発生）
                       390 **			タイマ使用およびタイマ割り込み	
                       391 ** 引数 :		t→%d1.w:	タイマの発生周期
                       392 ** 			p→%d2.l	割り込み時に起動するルーチンの先頭アドレス			
                       393 ******************************
                       394 SET_TIMER:
00070a 23C2 0000       395 		move.l	%d2, task_p /* 割り込み時に起動するルーチンの先頭アドレスpを大域
       0000            395 
000710 33FC 0086       396 		move.w	#0206, TPRER1 /* 0.1msec進むとカウンタが1増えるようにする */
       00FF F602       396 
000718 33C1 00FF       397 		move.w	%d1, TCMP1 /* t秒周期に設定 */
       F604            397 
00071e 33FC 0015       398 		move.w  #0x0015, TCTL1 /* タイマ1コントロールレジスタに0x0015を設定→割り込
       00FF F600       398 
000726 13FC 0074       399 		move.b	#'t', LED7
       00D0 002F       399 
00072e 13FC 0065       400 		move.b	#'e', LED6
       00D0 002D       400 
000736 13FC 0073       401 		move.b	#'s', LED5
       00D0 002B       401 
00073e 13FC 0074       402 		move.b	#'t', LED4	
       00D0 0029       402 
000746 4E75            403 		rts
                       404 
                       405 ******************************
                       406 ** CALL_RP():	タイマ割り込み時に処理すべきルーチン呼び出し
                       407 ******************************
                       408 CALL_RP:
000748 48E7 0080       409 		movem.l	%a0, -(%sp)
00074c 2079 0000       410 		movea.l task_p, %a0
       0000            410 
000752 4E90            411 		jsr (%a0)
000754 4CDF 0100       412 		movem.l (%sp)+, %a0
000758 4E75            413 		rts
                       414 
                       415 TEST_LIGHT:
00075a 13FC 0047       416 		move.b	#'G', LED7
       00D0 002F       416 
000762 13FC 0052       417 		move.b	#'R', LED6
       00D0 002D       417 
00076a 13FC 0038       418 		move.b	#'8', LED5
       00D0 002B       418 
000772 13FC 0054       419 		move.b	#'T', LED4
       00D0 0029       419 
00077a 13FC 0049       420 		move.b	#'I', LED3
       00D0 003F       420 
000782 13FC 004D       421 		move.b	#'M', LED2
       00D0 003D       421 
00078a 13FC 0045       422 		move.b	#'E', LED1
       00D0 003B       422 
000792 13FC 0052       423 		move.b	#'R', LED0
       00D0 0039       423 
00079a 4E75            424 		rts
                       425 
                       426 
                       427 
                       428 ******************************
                       429 ** キュー用のメモリ領域確保
                       430 ******************************
                       431 .section .data
                       432 .equ B_SIZE, 256
0007b4 0000 0000       433 top0:.ds.b B_SIZE-1
       0000 0000       433 
       0000 0000       433 
       0000 0000       433 
       0000 0000       433 
0008b3 00              434 bottom0:.ds.b 1
0008b4 0000 0000       435 top1:.ds.b B_SIZE-1
       0000 0000       435 
       0000 0000       435 
       0000 0000       435 
       0000 0000       435 
0009b3 00              436 bottom1:.ds.b 1
0009b4 0000 0000       437 out0:.ds.l 1
0009b8 0000 0000       438 out1:.ds.l 1
0009bc 0000 0000       439 in0:.ds.l 1
0009c0 0000 0000       440 in1:.ds.l 1
0009c4 0000 0000       441 s0:.ds.l 1                                                      
0009c8 0000 0000       442 s1:.ds.l 1
                       443 /* step5のテスト */
0009cc 3031 3233       444 TDATA1: .ascii "0123456789ABCDEF"
       3435 3637       444 
       3839 4142       444 
       4344 4546       444 
0009dc 6B6C 6D6E       445 TDATA2: .ascii "klmnopqrstuvwxyz"
       6F70 7172       445 
       7374 7576       445 
       7778 797A       445 
                       446 		
                       447 		
                       448 		
                       449 ***************************************************************
                       450 ** 現段階での初期化ルーチンの正常動作を確認するため,最後に ’a’ を
                       451 ** 送信レジスタ UTX1 に書き込む. ’a’ が出力されれば, OK.
                       452 ***************************************************************
                       453 .section .text
                       454 .even
                       455 MAIN:
                       456 	        *move.w #0x0800+'A', UTX1
00079c 4EBA FF62       457 		jsr	RESET_TIMER
0007a0 243C 0000       458 		move.l	#TEST_LIGHT, %d2
       0000            458 
0007a6 323C C350       459 		move.w	#50000, %d1
0007aa 4EBA FF5E       460 		jsr	SET_TIMER	
                       461 		
                       462 LOOP:
0007ae 6000 FFFE       463 		bra LOOP	
                       464 
