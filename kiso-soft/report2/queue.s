 .section .text
******************************
** メインルーチン
** a0:書き込む/読み出すデータの始めアドレス
** a4:書き込みデータの一時保存アドレス（データ量が256バイトを超える場合のみ用いる）
** a5:読み出しデータの一時保存アドレス（データ量が256バイトを超える場合のみ用いる）
** d3:キューの書き込み上限
** d4:書き込み/読み出しデータ数
******************************
Start:
	jsr     Init_Q /* キューの初期化処理 */
	lea.l   Data_to_Que, %a0 /* 書き込むデータの先頭アドレスをa0レジスタへ */
	move.l  #LENGTH, %d4 /* 書き込み回数をd4レジスタへ */
	move.l  #257, %d3 /* 書き込み上限 */

Loop1:
	subq.w  #1, %d4 /* 書き込みデータ数 - 1 */
	bcs     End_put /* d4 - 1 < 0 ならば書き込み完全終了 */
	subq.w  #1, %d3 /* 書き込み上限 - 1 */
	bcs     End_put /* d3 - 1 < 0 ならば書き込み一旦終了 */
	jsr     QueueIn /* 書き込み処理 */
	bra     Loop1 /* ループに戻る */

End_put:
	movea.l %a0,%a4 /* 次に書き込むデータの先頭アドレスを一時保存 */
	lea.l   COPY, %a0 /* 書き込むデータの先頭アドレスをa0レジスタへ */
	move.l  #LENGTH, %d4 /* 読み出し回数をd4レジスタへ */
	move.l  #257, %d3 /* 読み出し上限 */

Loop2:
	subq.w  #1, %d4 /* 読み出しデータ数 - 1 */
	bcs     End_program /* d4 - 1 < 0 ならば読み出し完全終了 */
	subq.w  #1, %d3 /* 読み出し上限 - 1 */
	bcs     End_get /* d3 - 1 < 0 ならば読み出し一旦終了 */
	jsr     QueueOut /* 読み出し処理 */
	bra     Loop2 /* ループに戻る */

End_get:
	movea.l %a4,%a0 /* 一時保存していた次に書き込むデータの先頭アドレスをa0レジスタに戻す */
	move.l  #257, %d3 /* 書き込み上限 */
	bra     Loop1

End_program:
	stop    #0x2700 /* 終了 */
**********************
** キューの初期化処理 (サブルーチン1）(p15)
**********************
Init_Q:
	lea.l   BF_START, %a2 /* キューのデータ領域の先頭アドレスをa2レジスタへ */
	move.l  %a2, PUT_PTR /* キューのデータ領域の先頭アドレス（a2）を書き込み用のポインタへ */
	move.l  %a2, GET_PTR /* キューのデータ領域の先頭アドレス（a2）を読み出し用のポインタへ */
	move.b  #0xff, PUT_FLG /* キューは「空」なので書き込み「許可」に設定 */
	move.b  #0x00, GET_FLG /* キューは「空」なので読み出し「禁止」に設定 */
	rts

***********************************
** QueueIn キューへのデータ書き込み（サブルーチン2）
** a0:書き込むデータのアドレス
** d0:結果(00:失敗, 00以外:成功)
***********************************
QueueIn:
	jsr PUT_BUF/* キューへの書き込み*/
	rts /* メインルーチンへ */
****************************************
** キューへのデータ書き込みPUT_BUF（サブルーチン2-1）(p15)
** a0:書き込むデータのアドレス
** d0:結果(00:失敗, 00以外:成功)
****************************************
PUT_BUF:
	movem.l %a1-%a4,-(%sp) /* レジスタ退避 */
	move.b  PUT_FLG, %d0 /* 書き込み許可フラグをd0レジスタへ */
	cmp.b   #0x00, %d0 /* 書き込み許可フラグ 0x00:禁止 | 0xff:許可 */
	beq     PUT_BUF_Finish /* 0x00で書き込み「禁止」なら終了 */
	movea.l PUT_PTR, %a1 /* 書き込み用のポインタアドレスをa1レジスタへ */
	move.b  (%a0)+,(%a1)+ /* データをキューへ入れ、書き込むデータアドレスと書き込み用ポインタを更新（+2） */
	lea.l   BF_END, %a3 /* キューデータ領域の末尾アドレスをa3レジスタへ */
	cmpa.l  %a3, %a1 /* 次書き込もうとしているアドレスa1とキューデータ領域の末尾アドレスa3を比較 */
	bls     PUT_BUF_STEP1 /* a1 < a3　ならば、そのままPUT_BUF_STEP1へ */
	lea.l   BF_START, %a2 /* 次書き込もうとしているアドレスa1とキューデータ領域の末尾アドレスa3を超えているならば、キューデータ領域の先頭アドレスをa2レジスタへ*/
	movea.l %a2,%a1 /* 書き込み用ポインタ(a1)をキューデータ領域の先頭アドレス(a2)に更新 */
PUT_BUF_STEP1:
	move.l  %a1,PUT_PTR /* 書き込み用ポインタを更新 */
	cmpa.l  GET_PTR,%a1 /* 読み出し用ポインタと書き込み用ポインタ(a1)を比較する */
	bne     PUT_BUF_STEP2 /* 書き込み用ポインタと読み出し用ポインタが異なる、つまりまだ書き込むことができればそのままPUT_BUF_STEP2へ */
	move.b  #0x00,PUT_FLG /* 書き込み用ポインタと読み出し用ポインタが同じなら、キューは一杯なので書き込み用ポインタを書き込み「禁止」に */
PUT_BUF_STEP2:
	move.b  #0xff, GET_FLG /* キューが一杯でなくなったので読み出し用ポインタを「許可」に */
PUT_BUF_Finish:
	movem.l (%sp)+, %a1-%a4 /* レジスタ復帰 */
	rts /* サブルーチンを抜ける */



***********************************
** QueueOut キューからのデータ読み出し（サブルーチン3）
** a0:読み出すデータのアドレス
** d0:結果(00:失敗, 00以外:成功)
***********************************
QueueOut:
	jsr GET_BUF/* キューへの書き込み*/
	rts /* メインルーチンへ */
****************************************
** キューへからのデータ読み出しGET_BUF（サブルーチン3-1）(p16)
** a0:読み出すデータのアドレス
** d0:結果(00:失敗, 00以外:成功)
****************************************
GET_BUF:
	movem.l %a1-%a4,-(%sp) /* レジスタ退避 */
	move.b  GET_FLG, %d0 /* 読み出し許可フラグをd0レジスタへ */
	cmp.b   #0x00, %d0 /* 読み出し許可フラグ 0x00:禁止 | 0xff:許可 */
	beq     GET_BUF_Finish /* 0x00で読み出し「禁止」なら終了 */
	movea.l GET_PTR, %a1 /* 読み出し用のポインタアドレスをa1レジスタへ */
	move.b  (%a1)+,(%a0)+ /* データをキューへ入れ、読み出しデータアドレスa1と読み出しデータ出力先のアドレスa0を更新（+2） */
	lea.l   BF_END, %a3 /* キューデータ領域の末尾アドレスをa3レジスタへ */
	cmpa.l  %a3, %a1 /* 次書き込もうとしているアドレスa1とキューデータ領域の末尾アドレスa3を比較 */
	bls     GET_BUF_STEP1 /* a1 < a3　ならば、そのままGET_BUF_STEP1へ */
	lea.l   BF_START, %a2 /* 次読み込もうとしているアドレスa1とキューデータ領域の末尾アドレスa3を超えているならば、キューデータ領域の先頭アドレスをa2レジスタへ*/
	movea.l %a2,%a1 /* 読み込み用ポインタ(a1)をキューデータ領域の先頭アドレス(a2)に更新 */
GET_BUF_STEP1:
	move.l  %a1,GET_PTR /* 読み出し用ポインタを更新 */
	cmpa.l  PUT_PTR,%a1 /* 書き込み用ポインタと読み出し用ポインタ(a1)を比較する */
	bne     GET_BUF_STEP2 /* 書き込み用ポインタと読み出し用ポインタが異なる、つまりまだ読み出すことができればそのままGET_BUF_STEP2へ */
	move.b  #0x00,GET_FLG /* 書き込み用ポインタと読み出し用ポインタが同じなら、キューは空なので書き込み用ポインタを読み出し「禁止」に */
GET_BUF_STEP2:
	move.b  #0xff, GET_FLG /* キューが空でなくなったので読み出し用ポインタを「許可」に */
GET_BUF_Finish:
	movea.l  %a0, %a5 /* 更新された読み出しデータ出力先のアドレスa0をCOPYに一時保存 */
	movem.l (%sp)+, %a1-%a4 /* レジスタ復帰 */
	rts /* サブルーチンを抜ける */





******************************
.section .data
******************************
**
**
** キュー用のメモリ領域確保
**
**
******************************
**キューのデータ領域は256バイト(p12)
	.equ	B_SIZE, 256 
******************************
**キューデータ領域の先頭アドレス(p12)
BF_START:	.ds.b	B_SIZE-1
******************************
**キューデータ領域の末尾アドレス(p13)
BF_END:		.ds.b	1
******************************
**キューに書き込むべきデータアドレスを管理するポインタ(p13)
PUT_PTR:	.ds.l	1
******************************
**キューから読み出すデータアドレスを管理するポインタ(p13)
GET_PTR:	.ds.l	1
******************************
**書き込み許可フラグ(p14)
**0x00 -> 書き込み禁止（buffer FULL）
**0xFF -> 書き込み許可
PUT_FLG:	.ds.b	1
******************************
**読み出し許可フラグ(p14)
**0x00 -> 読み出し禁止（buffer EMPTY）
**0xFF -> 読み出し許可
GET_FLG:	.ds.b	1
******************************


******************************
**
** 書き込むデータ（サンプル）
**
******************************
** 書き込みデータの長さ
	.equ        LENGTH,3
******************************
** 書き込むデータ
Data_to_Que:	.ascii	"ABC"
******************************

******************************
**
** 読み出し先
**
******************************
COPY:
	.ds.b 20          /* 読み出しデータ出力先 */

.end
